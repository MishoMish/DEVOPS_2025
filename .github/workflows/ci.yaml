name: CI/CD Pipeline

on:
  push:
    branches: [main, master, develop]
  pull_request:
    branches: [main, master]
  workflow_dispatch:
    inputs:
      run_all:
        description: 'Force run ALL jobs (for testing)'
        required: false
        type: boolean
        default: false

env:
  REGISTRY: ghcr.io
  IMAGE_OWNER: mishomish
  API_IMAGE_NAME: mishomish/api-service
  WEB_IMAGE_NAME: mishomish/web-service
  KUBECONFIG: /home/misho/.kube/config

jobs:
  # ==================== CHANGE DETECTION ====================
  
  # Detect which parts of the codebase changed
  detect-changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      api: ${{ steps.filter.outputs.api }}
      web: ${{ steps.filter.outputs.web }}
      db: ${{ steps.filter.outputs.db }}
      k8s: ${{ steps.filter.outputs.k8s }}
      workflow: ${{ steps.filter.outputs.workflow }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Detect file changes
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            api:
              - 'api-service/**'
            web:
              - 'web-service/**'
            db:
              - 'db/**'
            k8s:
              - 'k8s/**'
            workflow:
              - '.github/workflows/**'

      - name: Summary of changes
        run: |
          echo "## ðŸ” Change Detection Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Changed |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|---------|" >> $GITHUB_STEP_SUMMARY
          echo "| API Service | ${{ steps.filter.outputs.api }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Web Service | ${{ steps.filter.outputs.web }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Database | ${{ steps.filter.outputs.db }} |" >> $GITHUB_STEP_SUMMARY
          echo "| K8s Manifests | ${{ steps.filter.outputs.k8s }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Workflow | ${{ steps.filter.outputs.workflow }} |" >> $GITHUB_STEP_SUMMARY

  # ==================== CI PHASE ====================

  # Job 1: Test and Lint API Service (only if api-service changed)
  test-api:
    name: Test & Lint API Service
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.api == 'true' || needs.detect-changes.outputs.workflow == 'true' || inputs.run_all == true
    defaults:
      run:
        working-directory: ./api-service

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"
          cache-dependency-path: api-service/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint
        run: npm run lint

      - name: Run unit tests with coverage
        run: npm test -- --coverage --coverageReporters=text --coverageReporters=lcov

      - name: Check dependency vulnerabilities
        run: npm audit --audit-level=high
        continue-on-error: true # Don't fail on audit issues, but report them

      - name: Upload test coverage
        uses: actions/upload-artifact@v4
        with:
          name: api-coverage
          path: api-service/coverage/
          retention-days: 7

  # Job 1b: Lint Web Service (only if web-service changed)
  lint-web:
    name: Lint Web Service
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.web == 'true' || needs.detect-changes.outputs.workflow == 'true' || inputs.run_all == true
    defaults:
      run:
        working-directory: ./web-service

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js (for linting HTML/CSS/JS)
        uses: actions/setup-node@v4
        with:
          node-version: "18"

      - name: Install dependencies
        run: npm install --legacy-peer-deps || true

      - name: Run HTMLHint (HTML linter)
        run: npx htmlhint index.html || true

      - name: Run CSS linter
        run: npx stylelint "*.css" || echo "No CSS files or stylelint not configured"

      - name: Validate Nginx configuration
        run: |
          echo "âœ“ Checking nginx.conf syntax..."
          docker run --rm -v $(pwd):/etc/nginx nginx:alpine nginx -t -c /etc/nginx/nginx.conf 2>/dev/null || echo "âš ï¸  Nginx validation requires Docker - skipping syntax check"

  # Job 2: SAST - Static Application Security Testing (only if code changed)
  sast-scan:
    name: SAST Security Scan
    runs-on: ubuntu-latest
    needs: [detect-changes, test-api, lint-web]
    if: needs.detect-changes.outputs.api == 'true' || needs.detect-changes.outputs.web == 'true' || needs.detect-changes.outputs.workflow == 'true' || inputs.run_all == true
    permissions:
      contents: read
      security-events: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Semgrep SAST Scan
        uses: returntocorp/semgrep-action@v1
        with:
          config: >-
            p/security-audit
            p/secrets
            p/owasp-top-ten
            p/nodejs
        continue-on-error: true

      # Note: Semgrep SARIF upload requires Semgrep Pro
      # For demonstration, we continue on security findings

  # Job 3: Validate Database Migrations (only if db/ changed)
  validate-migrations:
    name: Validate SQL Migrations
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.db == 'true' || needs.detect-changes.outputs.workflow == 'true' || inputs.run_all == true
    env:
      DB_NAME: ${{ secrets.DB_NAME || 'devopsdb' }}
      DB_USER: ${{ secrets.DB_USER || 'devops' }}
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}

    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_DB: ${{ secrets.DB_NAME || 'devopsdb' }}
          POSTGRES_USER: ${{ secrets.DB_USER || 'devops' }}
          POSTGRES_PASSWORD: ${{ secrets.DB_PASSWORD }}
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate secrets are set
        run: |
          if [ -z "${{ secrets.DB_PASSWORD }}" ]; then
            echo "âš ï¸ Warning: DB_PASSWORD secret is not set. Using default for testing."
            echo "DB_PASSWORD=devops123" >> $GITHUB_ENV
            echo "DB_USER=devops" >> $GITHUB_ENV
            echo "DB_NAME=devopsdb" >> $GITHUB_ENV
          fi

      - name: Run Flyway migrations
        uses: docker://flyway/flyway:10-alpine
        with:
          args: >-
            -url=jdbc:postgresql://postgres:5432/${{ secrets.DB_NAME || 'devopsdb' }}
            -user=${{ secrets.DB_USER || 'devops' }}
            -password=${{ secrets.DB_PASSWORD || 'devops123' }}
            -locations=filesystem:./db/migrations
            -baselineOnMigrate=true
            -validateMigrationNaming=true
            migrate

      - name: Verify migration success
        run: |
          echo "âœ… Flyway migrations validated successfully!"
          echo "## ðŸ“Š Database Migration Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Status | Details |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|---------|" >> $GITHUB_STEP_SUMMARY
          echo "| âœ… Validated | All SQL migrations passed |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ“ Location | \`db/migrations/\` |" >> $GITHUB_STEP_SUMMARY

  # Job 4: Build Docker Images (only builds what changed)
  build-images:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: [detect-changes, test-api, lint-web, sast-scan, validate-migrations]
    # Run if any code changed (even if upstream jobs were skipped due to no changes)
    if: |
      always() && 
      (needs.detect-changes.outputs.api == 'true' || needs.detect-changes.outputs.web == 'true' || needs.detect-changes.outputs.workflow == 'true' || inputs.run_all == true) &&
      (needs.test-api.result == 'success' || needs.test-api.result == 'skipped') &&
      (needs.sast-scan.result == 'success' || needs.sast-scan.result == 'skipped') &&
      (needs.validate-migrations.result == 'success' || needs.validate-migrations.result == 'skipped')
    permissions:
      contents: read
      packages: write

    outputs:
      api-image-digest: ${{ steps.build-api.outputs.digest }}
      web-image-digest: ${{ steps.build-web.outputs.digest }}
      api-changed: ${{ needs.detect-changes.outputs.api }}
      web-changed: ${{ needs.detect-changes.outputs.web }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for API service
        id: meta-api
        if: needs.detect-changes.outputs.api == 'true' || needs.detect-changes.outputs.workflow == 'true' || inputs.run_all == true
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.API_IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push API service image
        id: build-api
        if: needs.detect-changes.outputs.api == 'true' || needs.detect-changes.outputs.workflow == 'true' || inputs.run_all == true
        uses: docker/build-push-action@v5
        with:
          context: ./api-service
          file: ./api-service/Dockerfile
          push: true
          tags: ${{ steps.meta-api.outputs.tags }}
          labels: ${{ steps.meta-api.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Extract metadata for Web service
        id: meta-web
        if: needs.detect-changes.outputs.web == 'true' || needs.detect-changes.outputs.workflow == 'true' || inputs.run_all == true
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.WEB_IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Web service image
        id: build-web
        if: needs.detect-changes.outputs.web == 'true' || needs.detect-changes.outputs.workflow == 'true' || inputs.run_all == true
        uses: docker/build-push-action@v5
        with:
          context: ./web-service
          file: ./web-service/Dockerfile
          push: true
          tags: ${{ steps.meta-web.outputs.tags }}
          labels: ${{ steps.meta-web.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build summary
        run: |
          echo "## ðŸ—ï¸ Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Service | Built |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| API Service | ${{ needs.detect-changes.outputs.api == 'true' && 'âœ… Yes' || 'â­ï¸ Skipped (no changes)' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Web Service | ${{ needs.detect-changes.outputs.web == 'true' && 'âœ… Yes' || 'â­ï¸ Skipped (no changes)' }} |" >> $GITHUB_STEP_SUMMARY

  # Job 5: Scan Docker Images for Vulnerabilities (only scans what was built)
  scan-images:
    name: Scan Images with Trivy
    runs-on: ubuntu-latest
    needs: [detect-changes, build-images]
    if: |
      always() && 
      needs.build-images.result == 'success' &&
      (needs.detect-changes.outputs.api == 'true' || needs.detect-changes.outputs.web == 'true' || needs.detect-changes.outputs.workflow == 'true' || inputs.run_all == true)
    permissions:
      contents: read
      security-events: write

    strategy:
      fail-fast: false
      matrix:
        include:
          - service: api-service
            changed: ${{ needs.detect-changes.outputs.api }}
          - service: web-service
            changed: ${{ needs.detect-changes.outputs.web }}

    steps:
      - name: Skip if service not changed
        if: matrix.changed != 'true' && needs.detect-changes.outputs.workflow != 'true' && github.event_name != 'workflow_dispatch'
        run: echo "â­ï¸ Skipping scan for ${{ matrix.service }} - no changes detected"

      - name: Checkout code
        if: matrix.changed == 'true' || needs.detect-changes.outputs.workflow == 'true' || inputs.run_all == true
        uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        if: matrix.changed == 'true' || needs.detect-changes.outputs.workflow == 'true' || inputs.run_all == true
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Run Trivy vulnerability scanner
        if: matrix.changed == 'true' || needs.detect-changes.outputs.workflow == 'true' || inputs.run_all == true
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ matrix.service == 'api-service' && env.API_IMAGE_NAME || env.WEB_IMAGE_NAME }}:${{ github.ref_name }}
          format: "table"
          exit-code: "0"
          severity: "CRITICAL,HIGH"
        continue-on-error: true

      - name: Run Trivy for JSON report
        if: matrix.changed == 'true' || needs.detect-changes.outputs.workflow == 'true' || inputs.run_all == true
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ matrix.service == 'api-service' && env.API_IMAGE_NAME || env.WEB_IMAGE_NAME }}:${{ github.ref_name }}
          format: "json"
          exit-code: "0"
          output: "trivy-${{ matrix.service }}-report.json"
        continue-on-error: true

      - name: Upload Trivy JSON report
        uses: actions/upload-artifact@v4
        with:
          name: trivy-${{ matrix.service }}-report
          path: "trivy-${{ matrix.service }}-report.json"
          retention-days: 30

  # ==================== CD PHASE ====================

  # Job 6: Deploy to Kubernetes (only deploys changed components)
  deploy-kubernetes:
    name: Deploy to Kubernetes
    runs-on: [self-hosted, k8s]
    needs: [detect-changes, build-images, scan-images]
    if: |
      always() &&
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') &&
      (needs.build-images.result == 'success' || needs.build-images.result == 'skipped') &&
      (needs.scan-images.result == 'success' || needs.scan-images.result == 'skipped')
    environment:
      name: production
      url: http://devops-demo.local

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify kubectl access
        run: |
          kubectl version --client
          kubectl cluster-info

      - name: Set image tag
        run: |
          # Use commit SHA for unique image tags
          IMAGE_TAG="${GITHUB_SHA:0:7}-$(date +%s)"
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          echo "API_CHANGED=${{ needs.detect-changes.outputs.api }}" >> $GITHUB_ENV
          echo "WEB_CHANGED=${{ needs.detect-changes.outputs.web }}" >> $GITHUB_ENV
          echo "DB_CHANGED=${{ needs.detect-changes.outputs.db }}" >> $GITHUB_ENV
          echo "K8S_CHANGED=${{ needs.detect-changes.outputs.k8s }}" >> $GITHUB_ENV

      - name: Build API Docker image (if changed)
        if: needs.detect-changes.outputs.api == 'true' || needs.detect-changes.outputs.workflow == 'true' || inputs.run_all == true
        run: |
          echo "ðŸ—ï¸ Building API service image..."
          docker build -t devops-demo/api-service:$IMAGE_TAG ./api-service
          docker tag devops-demo/api-service:$IMAGE_TAG devops-demo/api-service:latest

      - name: Build Web Docker image (if changed)
        if: needs.detect-changes.outputs.web == 'true' || needs.detect-changes.outputs.workflow == 'true' || inputs.run_all == true
        run: |
          echo "ðŸ—ï¸ Building Web service image..."
          docker build -t devops-demo/web-service:$IMAGE_TAG ./web-service
          docker tag devops-demo/web-service:$IMAGE_TAG devops-demo/web-service:latest

      - name: Import API image to K3s (if changed)
        if: needs.detect-changes.outputs.api == 'true' || needs.detect-changes.outputs.workflow == 'true' || inputs.run_all == true
        run: |
          docker save devops-demo/api-service:$IMAGE_TAG | sudo k3s ctr images import -
          docker save devops-demo/api-service:latest | sudo k3s ctr images import -
          echo "âœ… API image imported!"

      - name: Import Web image to K3s (if changed)
        if: needs.detect-changes.outputs.web == 'true' || needs.detect-changes.outputs.workflow == 'true' || inputs.run_all == true
        run: |
          docker save devops-demo/web-service:$IMAGE_TAG | sudo k3s ctr images import -
          docker save devops-demo/web-service:latest | sudo k3s ctr images import -
          echo "âœ… Web image imported!"

      - name: Verify imported images
        run: |
          sudo k3s ctr images list | grep devops-demo || echo "No devops-demo images found"
          echo "âœ… Images verified!"

      - name: Create namespace if not exists
        run: |
          kubectl get namespace devops-demo || kubectl create namespace devops-demo

      - name: Create database secrets from GitHub Secrets
        env:
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        run: |
          echo "ðŸ” Creating Kubernetes secrets from GitHub Secrets..."

          # Use defaults if secrets are not set (for backward compatibility)
          DB_NAME="${DB_NAME:-devopsdb}"
          DB_USER="${DB_USER:-devops}"
          DB_PASSWORD="${DB_PASSWORD:-devops123}"

          # Delete existing secret if exists
          kubectl delete secret postgres-secret -n devops-demo --ignore-not-found=true

          # Create secret from GitHub Secrets
          kubectl create secret generic postgres-secret \
            --namespace=devops-demo \
            --from-literal=POSTGRES_DB="$DB_NAME" \
            --from-literal=POSTGRES_USER="$DB_USER" \
            --from-literal=POSTGRES_PASSWORD="$DB_PASSWORD"

          # Apply the ConfigMap (non-sensitive config)
          kubectl apply -f k8s/postgres-secret.yaml --selector='!type=Opaque' 2>/dev/null || true

          # Create/update postgres-config ConfigMap
          kubectl create configmap postgres-config \
            --namespace=devops-demo \
            --from-literal=PGDATA=/var/lib/postgresql/data/pgdata \
            --dry-run=client -o yaml | kubectl apply -f -

          echo "âœ… Kubernetes secrets created from GitHub Secrets!"

      - name: Deploy PostgreSQL database
        run: |
          echo "ðŸ—„ï¸ Deploying PostgreSQL..."
          kubectl apply -f k8s/postgres-deployment.yaml

          # Wait for PostgreSQL to be ready
          kubectl rollout status deployment/postgres -n devops-demo --timeout=120s

          echo "âœ… PostgreSQL deployed successfully!"

      - name: Run Flyway database migrations
        run: |
          echo "ðŸ“Š Running database migrations..."
          echo "Note: Flyway only applies new/changed migrations automatically"

          # Apply Flyway ConfigMap and Job
          kubectl apply -f k8s/flyway-configmap.yaml

          # Delete previous job if exists
          kubectl delete job flyway-migrate -n devops-demo --ignore-not-found=true

          # Run migration job
          kubectl apply -f k8s/flyway-job.yaml

          # Wait for migration to complete
          kubectl wait --for=condition=complete job/flyway-migrate -n devops-demo --timeout=120s

          echo "âœ… Database migrations completed!"

      - name: Apply Kubernetes manifests (if k8s/ changed)
        if: needs.detect-changes.outputs.k8s == 'true' || needs.detect-changes.outputs.workflow == 'true' || inputs.run_all == true
        run: |
          echo "ðŸ“¦ Applying K8s manifests..."
          kubectl apply -f k8s/namespace.yaml
          kubectl apply -f k8s/api-deployment.yaml
          kubectl apply -f k8s/api-service.yaml
          kubectl apply -f k8s/web-deployment.yaml
          kubectl apply -f k8s/web-service.yaml
          kubectl apply -f k8s/ingress.yaml
          echo "âœ… K8s manifests applied!"

      - name: Update API service image (if API changed)
        if: needs.detect-changes.outputs.api == 'true' || needs.detect-changes.outputs.workflow == 'true' || inputs.run_all == true
        run: |
          echo "ðŸ”„ Updating API service to version: $IMAGE_TAG"

          # First, check the actual container name in the deployment
          CONTAINER_NAME=$(kubectl get deployment api-service -n devops-demo -o jsonpath='{.spec.template.spec.containers[0].name}')
          echo "Container name in deployment: $CONTAINER_NAME"

          # Set new image for API deployment using the actual container name
          kubectl set image deployment/api-service \
            $CONTAINER_NAME=devops-demo/api-service:$IMAGE_TAG \
            -n devops-demo

          # Annotate deployment to force update even if image is the same
          kubectl annotate deployment/api-service \
            kubernetes.io/change-cause="Deploy commit ${GITHUB_SHA:0:7} by ${GITHUB_ACTOR}" \
            -n devops-demo --overwrite

          # Add restart timestamp to ensure pods are recreated
          kubectl patch deployment api-service -n devops-demo \
            -p "{\"spec\":{\"template\":{\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/restartedAt\":\"$(date -Iseconds)\"}}}}}"

          echo "âœ… API service image updated, rolling update initiated"

      - name: Update Web service image (if Web changed)
        if: needs.detect-changes.outputs.web == 'true' || needs.detect-changes.outputs.workflow == 'true' || inputs.run_all == true
        run: |
          echo "ðŸ”„ Updating Web service to version: $IMAGE_TAG"

          # First, check the actual container name in the deployment
          CONTAINER_NAME=$(kubectl get deployment web-service -n devops-demo -o jsonpath='{.spec.template.spec.containers[0].name}')
          echo "Container name in deployment: $CONTAINER_NAME"

          # Set new image for Web deployment using the actual container name
          kubectl set image deployment/web-service \
            $CONTAINER_NAME=devops-demo/web-service:$IMAGE_TAG \
            -n devops-demo

          # Annotate deployment to force update
          kubectl annotate deployment/web-service \
            kubernetes.io/change-cause="Deploy commit ${GITHUB_SHA:0:7} by ${GITHUB_ACTOR}" \
            -n devops-demo --overwrite

          # Add restart timestamp to ensure pods are recreated
          kubectl patch deployment web-service -n devops-demo \
            -p "{\"spec\":{\"template\":{\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/restartedAt\":\"$(date -Iseconds)\"}}}}}"

          echo "âœ… Web service image updated, rolling update initiated"

      - name: Wait for API deployment rollout
        if: needs.detect-changes.outputs.api == 'true' || needs.detect-changes.outputs.workflow == 'true' || inputs.run_all == true
        run: |
          echo "â³ Waiting for API service rollout to complete..."
          kubectl rollout status deployment/api-service -n devops-demo --timeout=300s

          # Verify new pods are running
          echo "ðŸ“Š API service pod status:"
          kubectl get pods -n devops-demo -l app=api-service -o wide

      - name: Wait for Web deployment rollout
        if: needs.detect-changes.outputs.web == 'true' || needs.detect-changes.outputs.workflow == 'true' || inputs.run_all == true
        run: |
          echo "â³ Waiting for Web service rollout to complete..."
          kubectl rollout status deployment/web-service -n devops-demo --timeout=300s

          # Verify new pods are running
          echo "ðŸ“Š Web service pod status:"
          kubectl get pods -n devops-demo -l app=web-service -o wide

      - name: Verify deployment
        run: |
          echo "=== Deployments ==="
          kubectl get deployments -n devops-demo
          echo ""
          echo "=== Pods ==="
          kubectl get pods -n devops-demo -o wide
          echo ""
          echo "=== Services ==="
          kubectl get services -n devops-demo
          echo ""
          echo "=== Ingress ==="
          kubectl get ingress -n devops-demo
          echo ""
          echo "=== Deployment History ==="
          echo "API Service:"
          kubectl rollout history deployment/api-service -n devops-demo
          echo ""
          echo "Web Service:"
          kubectl rollout history deployment/web-service -n devops-demo

      - name: Check pod health
        run: |
          # Wait a bit for pods to stabilize
          sleep 15

          # Get pod status
          API_PODS=$(kubectl get pods -n devops-demo -l app=api-service -o jsonpath='{.items[*].status.phase}')
          WEB_PODS=$(kubectl get pods -n devops-demo -l app=web-service -o jsonpath='{.items[*].status.phase}')
          DB_PODS=$(kubectl get pods -n devops-demo -l app=postgres -o jsonpath='{.items[*].status.phase}')

          echo "API Pods Status: $API_PODS"
          echo "Web Pods Status: $WEB_PODS"
          echo "Database Pods Status: $DB_PODS"

          # Check if all pods are running
          if [[ "$API_PODS" == *"Running"* ]] && [[ "$WEB_PODS" == *"Running"* ]] && [[ "$DB_PODS" == *"Running"* ]]; then
            echo "âœ… All pods are running successfully!"
            
            # Show pod ages to confirm they were recently updated
            echo ""
            echo "ðŸ“… Pod ages (should show recent restart):"
            kubectl get pods -n devops-demo -o custom-columns=NAME:.metadata.name,STATUS:.status.phase,AGE:.metadata.creationTimestamp
          else
            echo "âŒ Some pods are not running properly"
            kubectl get pods -n devops-demo
            kubectl describe pods -n devops-demo
            exit 1
          fi

      - name: Deployment summary
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Changes Deployed" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          if [[ "$API_CHANGED" == "true" ]]; then
            echo "| API Service | âœ… Updated |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| API Service | â­ï¸ Skipped (no changes) |" >> $GITHUB_STEP_SUMMARY
          fi
          if [[ "$WEB_CHANGED" == "true" ]]; then
            echo "| Web Service | âœ… Updated |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Web Service | â­ï¸ Skipped (no changes) |" >> $GITHUB_STEP_SUMMARY
          fi
          if [[ "$DB_CHANGED" == "true" ]]; then
            echo "| Database Migrations | âœ… Applied |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Database Migrations | â­ï¸ Skipped (no new migrations) |" >> $GITHUB_STEP_SUMMARY
          fi
          if [[ "$K8S_CHANGED" == "true" ]]; then
            echo "| K8s Manifests | âœ… Applied |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| K8s Manifests | â­ï¸ Skipped (no changes) |" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Optimized Deployment" >> $GITHUB_STEP_SUMMARY
          echo "This pipeline uses **path-based filtering** to only build and deploy changed components, saving CI/CD resources and time." >> $GITHUB_STEP_SUMMARY

      - name: Cleanup old images from K3s
        run: |
          echo "ðŸ§¹ Cleaning up old images..."
          # List all devops-demo images
          sudo k3s ctr images list | grep devops-demo || true

          # Note: You can add pruning logic here if needed
          # For now, we keep recent images for potential rollback
          echo "âœ… Image cleanup check completed"
        continue-on-error: true

  # Job 7: End-to-End Tests
  e2e-tests:
    name: E2E Tests
    runs-on: [self-hosted, k8s]
    needs: deploy-kubernetes
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'

    steps:
      - name: Test API health endpoint
        run: |
          echo "ðŸ§ª Testing API health..."
          API_POD=$(kubectl get pods -n devops-demo -l app=api-service -o jsonpath='{.items[0].metadata.name}')
          HEALTH=$(kubectl exec -n devops-demo $API_POD -- wget -qO- http://localhost:3000/health 2>/dev/null || echo '{"status":"error"}')
          echo "Health response: $HEALTH"

          if echo "$HEALTH" | grep -q "healthy"; then
            echo "âœ… API health check passed!"
          else
            echo "âŒ API health check failed!"
            exit 1
          fi

      - name: Test API hello endpoint
        run: |
          echo "ðŸ§ª Testing API hello endpoint..."
          API_POD=$(kubectl get pods -n devops-demo -l app=api-service -o jsonpath='{.items[0].metadata.name}')
          HELLO=$(kubectl exec -n devops-demo $API_POD -- wget -qO- http://localhost:3000/api/hello 2>/dev/null || echo '{"message":"error"}')
          echo "Hello response: $HELLO"

          if echo "$HELLO" | grep -q "Hello from the API"; then
            echo "âœ… API hello endpoint passed!"
          else
            echo "âŒ API hello endpoint failed!"
            exit 1
          fi

      - name: Test database connectivity
        run: |
          echo "ðŸ§ª Testing database connectivity..."
          API_POD=$(kubectl get pods -n devops-demo -l app=api-service -o jsonpath='{.items[0].metadata.name}')
          DB_INFO=$(kubectl exec -n devops-demo $API_POD -- wget -qO- http://localhost:3000/api/db-info 2>/dev/null || echo '{"connected":false}')
          echo "DB Info response: $DB_INFO"

          if echo "$DB_INFO" | grep -q '"connected":true'; then
            echo "âœ… Database connectivity test passed!"
          else
            echo "âš ï¸ Database not connected (may need time to initialize)"
          fi

      - name: Test messages endpoint
        run: |
          echo "ðŸ§ª Testing messages endpoint..."
          API_POD=$(kubectl get pods -n devops-demo -l app=api-service -o jsonpath='{.items[0].metadata.name}')
          MESSAGES=$(kubectl exec -n devops-demo $API_POD -- wget -qO- http://localhost:3000/api/messages 2>/dev/null || echo '{"messages":[]}')
          echo "Messages response: $MESSAGES"
          echo "âœ… Messages endpoint responding!"

      - name: Generate E2E test report
        run: |
          echo "## ðŸ§ª E2E Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Test | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| API Health | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          echo "| API Hello | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          echo "| Database Connectivity | âœ… Tested |" >> $GITHUB_STEP_SUMMARY
          echo "| Messages Endpoint | âœ… Passed |" >> $GITHUB_STEP_SUMMARY

  # Job 8: Deployment Notification
  notify:
    name: Deployment Notification
    runs-on: ubuntu-latest
    needs: [deploy-kubernetes, e2e-tests]
    if: always()

    steps:
      - name: Create deployment summary
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deploy Status:** ${{ needs.deploy-kubernetes.result }}" >> $GITHUB_STEP_SUMMARY
          echo "**E2E Tests:** ${{ needs.e2e-tests.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“¦ Images Deployed:" >> $GITHUB_STEP_SUMMARY
          echo "- API Service: \`${{ env.REGISTRY }}/${{ env.API_IMAGE_NAME }}:${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Web Service: \`${{ env.REGISTRY }}/${{ env.WEB_IMAGE_NAME }}:${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ—„ï¸ Database:" >> $GITHUB_STEP_SUMMARY
          echo "- PostgreSQL: \`15-alpine\`" >> $GITHUB_STEP_SUMMARY
          echo "- Migrations: Flyway" >> $GITHUB_STEP_SUMMARY
