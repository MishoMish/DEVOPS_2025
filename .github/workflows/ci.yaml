name: CI/CD Pipeline

on:
  push:
    branches: [main, master, develop]
  pull_request:
    branches: [main, master]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_OWNER: mishomish
  API_IMAGE_NAME: mishomish/api-service
  WEB_IMAGE_NAME: mishomish/web-service
  KUBECONFIG: ${{ github.runner.workspace }}/.kube/config

jobs:
  # ==================== CI PHASE ====================

  # Job 1: Test and Lint API Service
  test-api:
    name: Test & Lint API Service
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./api-service

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"
          cache-dependency-path: api-service/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint
        run: npm run lint

      - name: Run unit tests with coverage
        run: npm test -- --coverage --coverageReporters=text --coverageReporters=lcov

      - name: Check dependency vulnerabilities
        run: npm audit --audit-level=high
        continue-on-error: true # Don't fail on audit issues, but report them

      - name: Upload test coverage
        uses: actions/upload-artifact@v4
        with:
          name: api-coverage
          path: api-service/coverage/
          retention-days: 7

  # Job 2: SAST - Static Application Security Testing
  sast-scan:
    name: SAST Security Scan
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Semgrep SAST Scan
        uses: returntocorp/semgrep-action@v1
        with:
          config: >-
            p/security-audit
            p/secrets
            p/owasp-top-ten
            p/nodejs
        continue-on-error: true

      # Note: Semgrep SARIF upload requires Semgrep Pro
      # For demonstration, we continue on security findings

  # Job 3: Validate Database Migrations
  validate-migrations:
    name: Validate SQL Migrations
    runs-on: ubuntu-latest
    env:
      DB_NAME: ${{ secrets.DB_NAME || 'devopsdb' }}
      DB_USER: ${{ secrets.DB_USER || 'devops' }}
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}

    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_DB: ${{ secrets.DB_NAME || 'devopsdb' }}
          POSTGRES_USER: ${{ secrets.DB_USER || 'devops' }}
          POSTGRES_PASSWORD: ${{ secrets.DB_PASSWORD }}
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate secrets are set
        run: |
          if [ -z "${{ secrets.DB_PASSWORD }}" ]; then
            echo "âš ï¸ Warning: DB_PASSWORD secret is not set. Using default for testing."
            echo "DB_PASSWORD=devops123" >> $GITHUB_ENV
            echo "DB_USER=devops" >> $GITHUB_ENV
            echo "DB_NAME=devopsdb" >> $GITHUB_ENV
          fi

      - name: Run Flyway migrations
        uses: docker://flyway/flyway:10-alpine
        with:
          args: >-
            -url=jdbc:postgresql://postgres:5432/${{ secrets.DB_NAME || 'devopsdb' }}
            -user=${{ secrets.DB_USER || 'devops' }}
            -password=${{ secrets.DB_PASSWORD || 'devops123' }}
            -locations=filesystem:./db/migrations
            -baselineOnMigrate=true
            -validateMigrationNaming=true
            migrate

      - name: Verify migration success
        run: |
          echo "âœ… Flyway migrations validated successfully!"
          echo "## ðŸ“Š Database Migration Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Status | Details |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|---------|" >> $GITHUB_STEP_SUMMARY
          echo "| âœ… Validated | All SQL migrations passed |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ“ Location | \`db/migrations/\` |" >> $GITHUB_STEP_SUMMARY

  # Job 4: Build Docker Images
  build-images:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: [test-api, sast-scan, validate-migrations]
    permissions:
      contents: read
      packages: write

    outputs:
      api-image-digest: ${{ steps.build-api.outputs.digest }}
      web-image-digest: ${{ steps.build-web.outputs.digest }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for API service
        id: meta-api
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.API_IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push API service image
        id: build-api
        uses: docker/build-push-action@v5
        with:
          context: ./api-service
          file: ./api-service/Dockerfile
          push: true
          tags: ${{ steps.meta-api.outputs.tags }}
          labels: ${{ steps.meta-api.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Extract metadata for Web service
        id: meta-web
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.WEB_IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Web service image
        id: build-web
        uses: docker/build-push-action@v5
        with:
          context: ./web-service
          file: ./web-service/Dockerfile
          push: true
          tags: ${{ steps.meta-web.outputs.tags }}
          labels: ${{ steps.meta-web.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Job 5: Scan Docker Images for Vulnerabilities
  scan-images:
    name: Scan Images with Trivy
    runs-on: ubuntu-latest
    needs: build-images
    permissions:
      contents: read
      security-events: write

    strategy:
      matrix:
        include:
          - service: api-service
          - service: web-service

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ matrix.service == 'api-service' && env.API_IMAGE_NAME || env.WEB_IMAGE_NAME }}:${{ github.ref_name }}
          format: "table"
          exit-code: "0"
          severity: "CRITICAL,HIGH"
        continue-on-error: true

      - name: Run Trivy for JSON report
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ matrix.service == 'api-service' && env.API_IMAGE_NAME || env.WEB_IMAGE_NAME }}:${{ github.ref_name }}
          format: "json"
          exit-code: "0"
          output: "trivy-${{ matrix.service }}-report.json"
        continue-on-error: true

      - name: Upload Trivy JSON report
        uses: actions/upload-artifact@v4
        with:
          name: trivy-${{ matrix.service }}-report
          path: "trivy-${{ matrix.service }}-report.json"
          retention-days: 30

  # ==================== CD PHASE ====================

  # Job 6: Deploy to Kubernetes
  deploy-kubernetes:
    name: Deploy to Kubernetes
    runs-on: [self-hosted, k8s]
    needs: [build-images, scan-images]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    environment:
      name: production
      url: http://devops-demo.local
    env:
      KUBECONFIG: /home/misho/.kube/config

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify kubectl access
        run: |
          kubectl version --client
          kubectl cluster-info

      - name: Build Docker images locally with unique tag
        run: |
          # Use commit SHA for unique image tags
          IMAGE_TAG="${GITHUB_SHA:0:7}-$(date +%s)"
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV

          docker build -t devops-demo/api-service:$IMAGE_TAG ./api-service
          docker build -t devops-demo/web-service:$IMAGE_TAG ./web-service

          # Also tag as latest for convenience
          docker tag devops-demo/api-service:$IMAGE_TAG devops-demo/api-service:latest
          docker tag devops-demo/web-service:$IMAGE_TAG devops-demo/web-service:latest

      - name: Import images to K3s
        run: |
          # Save and import images to K3s containerd with unique tag
          docker save devops-demo/api-service:$IMAGE_TAG | sudo k3s ctr images import -
          docker save devops-demo/web-service:$IMAGE_TAG | sudo k3s ctr images import -

          # Also import latest tags
          docker save devops-demo/api-service:latest | sudo k3s ctr images import -
          docker save devops-demo/web-service:latest | sudo k3s ctr images import -

          # Verify images are available
          sudo k3s ctr images list | grep devops-demo
          echo "âœ… Images imported successfully!"

      - name: Create namespace if not exists
        run: |
          kubectl get namespace devops-demo || kubectl create namespace devops-demo

      - name: Create database secrets from GitHub Secrets
        env:
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        run: |
          echo "ðŸ” Creating Kubernetes secrets from GitHub Secrets..."

          # Use defaults if secrets are not set (for backward compatibility)
          DB_NAME="${DB_NAME:-devopsdb}"
          DB_USER="${DB_USER:-devops}"
          DB_PASSWORD="${DB_PASSWORD:-devops123}"

          # Delete existing secret if exists
          kubectl delete secret postgres-secret -n devops-demo --ignore-not-found=true

          # Create secret from GitHub Secrets
          kubectl create secret generic postgres-secret \
            --namespace=devops-demo \
            --from-literal=POSTGRES_DB="$DB_NAME" \
            --from-literal=POSTGRES_USER="$DB_USER" \
            --from-literal=POSTGRES_PASSWORD="$DB_PASSWORD"

          # Apply the ConfigMap (non-sensitive config)
          kubectl apply -f k8s/postgres-secret.yaml --selector='!type=Opaque' 2>/dev/null || true

          # Create/update postgres-config ConfigMap
          kubectl create configmap postgres-config \
            --namespace=devops-demo \
            --from-literal=PGDATA=/var/lib/postgresql/data/pgdata \
            --dry-run=client -o yaml | kubectl apply -f -

          echo "âœ… Kubernetes secrets created from GitHub Secrets!"

      - name: Deploy PostgreSQL database
        run: |
          echo "ðŸ—„ï¸ Deploying PostgreSQL..."
          kubectl apply -f k8s/postgres-deployment.yaml

          # Wait for PostgreSQL to be ready
          kubectl rollout status deployment/postgres -n devops-demo --timeout=120s

          echo "âœ… PostgreSQL deployed successfully!"

      - name: Run Flyway database migrations
        run: |
          echo "ðŸ“Š Running database migrations..."

          # Apply Flyway ConfigMap and Job
          kubectl apply -f k8s/flyway-configmap.yaml

          # Delete previous job if exists
          kubectl delete job flyway-migrate -n devops-demo --ignore-not-found=true

          # Run migration job
          kubectl apply -f k8s/flyway-job.yaml

          # Wait for migration to complete
          kubectl wait --for=condition=complete job/flyway-migrate -n devops-demo --timeout=120s

          echo "âœ… Database migrations completed!"

      - name: Apply base Kubernetes manifests
        run: |
          kubectl apply -f k8s/namespace.yaml
          kubectl apply -f k8s/api-deployment.yaml
          kubectl apply -f k8s/api-service.yaml
          kubectl apply -f k8s/web-deployment.yaml
          kubectl apply -f k8s/web-service.yaml
          kubectl apply -f k8s/ingress.yaml

      - name: Update API service image and rolling update
        run: |
          echo "ðŸ”„ Updating API service to version: $IMAGE_TAG"

          # First, check the actual container name in the deployment
          CONTAINER_NAME=$(kubectl get deployment api-service -n devops-demo -o jsonpath='{.spec.template.spec.containers[0].name}')
          echo "Container name in deployment: $CONTAINER_NAME"

          # Set new image for API deployment using the actual container name
          kubectl set image deployment/api-service \
            $CONTAINER_NAME=devops-demo/api-service:$IMAGE_TAG \
            -n devops-demo

          # Annotate deployment to force update even if image is the same
          kubectl annotate deployment/api-service \
            kubernetes.io/change-cause="Deploy commit ${GITHUB_SHA:0:7} by ${GITHUB_ACTOR}" \
            -n devops-demo --overwrite

          # Add restart timestamp to ensure pods are recreated
          kubectl patch deployment api-service -n devops-demo \
            -p "{\"spec\":{\"template\":{\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/restartedAt\":\"$(date -Iseconds)\"}}}}}"

          echo "âœ… API service image updated, rolling update initiated"

      - name: Update Web service image and rolling update
        run: |
          echo "ðŸ”„ Updating Web service to version: $IMAGE_TAG"

          # First, check the actual container name in the deployment
          CONTAINER_NAME=$(kubectl get deployment web-service -n devops-demo -o jsonpath='{.spec.template.spec.containers[0].name}')
          echo "Container name in deployment: $CONTAINER_NAME"

          # Set new image for Web deployment using the actual container name
          kubectl set image deployment/web-service \
            $CONTAINER_NAME=devops-demo/web-service:$IMAGE_TAG \
            -n devops-demo

          # Annotate deployment to force update
          kubectl annotate deployment/web-service \
            kubernetes.io/change-cause="Deploy commit ${GITHUB_SHA:0:7} by ${GITHUB_ACTOR}" \
            -n devops-demo --overwrite

          # Add restart timestamp to ensure pods are recreated
          kubectl patch deployment web-service -n devops-demo \
            -p "{\"spec\":{\"template\":{\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/restartedAt\":\"$(date -Iseconds)\"}}}}}"

          echo "âœ… Web service image updated, rolling update initiated"

      - name: Wait for API deployment rollout
        run: |
          echo "â³ Waiting for API service rollout to complete..."
          kubectl rollout status deployment/api-service -n devops-demo --timeout=300s

          # Verify new pods are running
          echo "ðŸ“Š API service pod status:"
          kubectl get pods -n devops-demo -l app=api-service -o wide

      - name: Wait for Web deployment rollout
        run: |
          echo "â³ Waiting for Web service rollout to complete..."
          kubectl rollout status deployment/web-service -n devops-demo --timeout=300s

          # Verify new pods are running
          echo "ðŸ“Š Web service pod status:"
          kubectl get pods -n devops-demo -l app=web-service -o wide

      - name: Verify deployment
        run: |
          echo "=== Deployments ==="
          kubectl get deployments -n devops-demo
          echo ""
          echo "=== Pods ==="
          kubectl get pods -n devops-demo -o wide
          echo ""
          echo "=== Services ==="
          kubectl get services -n devops-demo
          echo ""
          echo "=== Ingress ==="
          kubectl get ingress -n devops-demo
          echo ""
          echo "=== Deployment History ==="
          echo "API Service:"
          kubectl rollout history deployment/api-service -n devops-demo
          echo ""
          echo "Web Service:"
          kubectl rollout history deployment/web-service -n devops-demo

      - name: Check pod health
        run: |
          # Wait a bit for pods to stabilize
          sleep 15

          # Get pod status
          API_PODS=$(kubectl get pods -n devops-demo -l app=api-service -o jsonpath='{.items[*].status.phase}')
          WEB_PODS=$(kubectl get pods -n devops-demo -l app=web-service -o jsonpath='{.items[*].status.phase}')
          DB_PODS=$(kubectl get pods -n devops-demo -l app=postgres -o jsonpath='{.items[*].status.phase}')

          echo "API Pods Status: $API_PODS"
          echo "Web Pods Status: $WEB_PODS"
          echo "Database Pods Status: $DB_PODS"

          # Check if all pods are running
          if [[ "$API_PODS" == *"Running"* ]] && [[ "$WEB_PODS" == *"Running"* ]] && [[ "$DB_PODS" == *"Running"* ]]; then
            echo "âœ… All pods are running successfully!"
            
            # Show pod ages to confirm they were recently updated
            echo ""
            echo "ðŸ“… Pod ages (should show recent restart):"
            kubectl get pods -n devops-demo -o custom-columns=NAME:.metadata.name,STATUS:.status.phase,AGE:.metadata.creationTimestamp
          else
            echo "âŒ Some pods are not running properly"
            kubectl get pods -n devops-demo
            kubectl describe pods -n devops-demo
            exit 1
          fi

      - name: Cleanup old images from K3s
        run: |
          echo "ðŸ§¹ Cleaning up old images..."
          # List all devops-demo images
          sudo k3s ctr images list | grep devops-demo || true

          # Note: You can add pruning logic here if needed
          # For now, we keep recent images for potential rollback
          echo "âœ… Image cleanup check completed"
        continue-on-error: true

  # Job 7: End-to-End Tests
  e2e-tests:
    name: E2E Tests
    runs-on: [self-hosted, k8s]
    needs: deploy-kubernetes
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    env:
      KUBECONFIG: /home/misho/.kube/config

    steps:
      - name: Test API health endpoint
        run: |
          echo "ðŸ§ª Testing API health..."
          API_POD=$(kubectl get pods -n devops-demo -l app=api-service -o jsonpath='{.items[0].metadata.name}')
          HEALTH=$(kubectl exec -n devops-demo $API_POD -- wget -qO- http://localhost:3000/health 2>/dev/null || echo '{"status":"error"}')
          echo "Health response: $HEALTH"

          if echo "$HEALTH" | grep -q "healthy"; then
            echo "âœ… API health check passed!"
          else
            echo "âŒ API health check failed!"
            exit 1
          fi

      - name: Test API hello endpoint
        run: |
          echo "ðŸ§ª Testing API hello endpoint..."
          API_POD=$(kubectl get pods -n devops-demo -l app=api-service -o jsonpath='{.items[0].metadata.name}')
          HELLO=$(kubectl exec -n devops-demo $API_POD -- wget -qO- http://localhost:3000/api/hello 2>/dev/null || echo '{"message":"error"}')
          echo "Hello response: $HELLO"

          if echo "$HELLO" | grep -q "Hello from the API"; then
            echo "âœ… API hello endpoint passed!"
          else
            echo "âŒ API hello endpoint failed!"
            exit 1
          fi

      - name: Test database connectivity
        run: |
          echo "ðŸ§ª Testing database connectivity..."
          API_POD=$(kubectl get pods -n devops-demo -l app=api-service -o jsonpath='{.items[0].metadata.name}')
          DB_INFO=$(kubectl exec -n devops-demo $API_POD -- wget -qO- http://localhost:3000/api/db-info 2>/dev/null || echo '{"connected":false}')
          echo "DB Info response: $DB_INFO"

          if echo "$DB_INFO" | grep -q '"connected":true'; then
            echo "âœ… Database connectivity test passed!"
          else
            echo "âš ï¸ Database not connected (may need time to initialize)"
          fi

      - name: Test messages endpoint
        run: |
          echo "ðŸ§ª Testing messages endpoint..."
          API_POD=$(kubectl get pods -n devops-demo -l app=api-service -o jsonpath='{.items[0].metadata.name}')
          MESSAGES=$(kubectl exec -n devops-demo $API_POD -- wget -qO- http://localhost:3000/api/messages 2>/dev/null || echo '{"messages":[]}')
          echo "Messages response: $MESSAGES"
          echo "âœ… Messages endpoint responding!"

      - name: Generate E2E test report
        run: |
          echo "## ðŸ§ª E2E Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Test | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| API Health | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          echo "| API Hello | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          echo "| Database Connectivity | âœ… Tested |" >> $GITHUB_STEP_SUMMARY
          echo "| Messages Endpoint | âœ… Passed |" >> $GITHUB_STEP_SUMMARY

  # Job 8: Deployment Notification
  notify:
    name: Deployment Notification
    runs-on: ubuntu-latest
    needs: [deploy-kubernetes, e2e-tests]
    if: always()

    steps:
      - name: Create deployment summary
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deploy Status:** ${{ needs.deploy-kubernetes.result }}" >> $GITHUB_STEP_SUMMARY
          echo "**E2E Tests:** ${{ needs.e2e-tests.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“¦ Images Deployed:" >> $GITHUB_STEP_SUMMARY
          echo "- API Service: \`${{ env.REGISTRY }}/${{ env.API_IMAGE_NAME }}:${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Web Service: \`${{ env.REGISTRY }}/${{ env.WEB_IMAGE_NAME }}:${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ—„ï¸ Database:" >> $GITHUB_STEP_SUMMARY
          echo "- PostgreSQL: \`15-alpine\`" >> $GITHUB_STEP_SUMMARY
          echo "- Migrations: Flyway" >> $GITHUB_STEP_SUMMARY
